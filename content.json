{"meta":{"title":"Rainbow","subtitle":"Rainbow's Blog","description":"生命不息，摸鱼不止","author":"Rainbow Chen","url":"https://yunbochen.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2022-01-24T03:33:13.998Z","updated":"2022-01-24T03:33:13.998Z","comments":true,"path":"categories/index.html","permalink":"https://yunbochen.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-01-24T03:33:13.998Z","updated":"2022-01-24T03:33:13.998Z","comments":true,"path":"tags/index.html","permalink":"https://yunbochen.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"编写一个简单的前端脚手架","slug":"note/node/编写一个简单的前端脚手架","date":"2022-01-20T15:03:36.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"note/node/编写一个简单的前端脚手架.html","link":"","permalink":"https://yunbochen.github.io/note/node/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6.html","excerpt":"","text":"前端脚手架基本都是利用 Node.js 对内置的项目模板进行相关的文件操作（读、写、删等）来生成目标项目。 基础知识 正式开始之前，需要了解 Node.js 相关的基础知识。 __dirname 和 __filename __dirname 指的是 当前运行项目的所在目录路径，例如： 12console.log(__dirname)// 输出目录路径 /Users/rainbow/workspace/study/copyfile __filename 指的是 当前运行文件的路径，例如： 12console.log(__filename)// 输出运行文件的路径 /Users/rainbow/workspace/study/copyfile/index.js 路径解析 对路径进行相关解析时，需要引入 path 模块。 1const path = require(&#x27;path&#x27;) path.resolve 指的是 路径或路径片段的序列解析为绝对路径，例如： 12345678console.log(path.resolve(__dirname, &#x27;test&#x27;))// 输出 /Users/rainbow/workspace/study/copyfile/testconsole.log(path.resolve(__dirname, &#x27;../test&#x27;))// 输出 /Users/rainbow/workspace/study/testconsole.log(path.resolve(&#x27;a&#x27;, &#x27;b&#x27;))// 输出 /Users/rainbow/workspace/study/copyfile/a/b path.join 指的是 特定于平台的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。 12console.log(path.join(&#x27;a&#x27;, &#x27;b&#x27;))// 输出 a/b path.resolve 是 从右往左 进行路径的解析并生成绝对路径，path.join 则是 从左往右 进行路劲的拼接。若某个参数以 / 开头, path.resolve 则以这个参数为根目录进行路径的解析。 文件操作 对文件进行创建、复制、删除，需要引入 fs 模块。 12const fs = require(&#x27;fs&#x27;)// node 文件处理模块 写文件 fs.writeFile(file, data[, options], callback) file ：文件名或文件描述符 data ：具体的写入内容 options (可选) ： encoding : 编码格式，默认值：utf-8 … callback ：回调方法 fs.writeFilehttps://nodejs.org/dist/latest-v16.x/docs/api/fs.html#fswritefilefile-data-options-callback fs.writeFileSync(file, data[, options]) 与 fs.writeFile 用法一致。区别在于：fs.writeFileSync 为同步的，而 fs.writeFile 为异步的。 123456789101112const fs = require(&#x27;fs&#x27;)fs.writeFile(&#x27;test.js&#x27;, &#x27;Hello world !&#x27;, &#x27;utf8&#x27;, (err) =&gt; &#123; if (err) throw err; console.log(&#x27;文件保存成功!&#x27;);&#125;)// or fs.writeFileSync(&#x27;test.js&#x27;, &#x27;Hello world !&#x27;, &#x27;utf8&#x27;)// 项目运行目录下会生成一个 test.js 若文件已存在，则会覆盖该文件。 复制文件 fs.copyFile(src, dest[, mode], callback) src ：要复制的源文件名 dest ：复制操作的目标文件名 mode ：复制操作的修饰符。 默认值: 0 。 callback ：回调方法 fs.copyFilehttps://nodejs.org/dist/latest-v16.x/docs/api/fs.html#fscopyfilesrc-dest-mode-callback fs.copyFileSync(src, dest[, mode]) 与 fs.copyFile 用法相似，区别在于, fs.copyFileSync 为同步的。例如： 1234567891011const fs = require(&#x27;fs&#x27;)fs.copyFile(&#x27;test.js&#x27;, &#x27;copy.js&#x27;, (err) =&gt; &#123; if (err) throw err; console.log(&#x27;文件已复制&#x27;);&#125;)// orfs.copyFileSync(&#x27;test.js&#x27;, &#x27;copy.js&#x27;) 删除文件 删除文件一般用于脚手架开始生成项目时，会去目标目录检测是否存在相同的项目文件夹，若存在会提示用户是否覆盖，这时就要用到删除文件的功能。 删除文件 fs.unlink(path, callback) path ：目标路径 callback ：回调函数 fs.unlinkhttps://nodejs.org/dist/latest-v16.x/docs/api/fs.html#fsunlinkpath-callback fs.unlinkSync(path) 与 fs.unlink 用法相同，区别在于，fs.unlinkSync 为同步方法，例如： 1234567891011const fs = require(&#x27;fs&#x27;)fs.unlink(&#x27;test.js&#x27;, err =&gt; &#123; if(err) throw err console.log(&#x27;文件已删除&#x27;)&#125;)// or fs.unlinkSync(&#x27;test.js&#x27;)console.log(&#x27;文件已删除&#x27;) 删除文件夹 fs.rmdir(path[, options], callback) path ：目标路径 options（可选）：相关配置，详情 点击查看文档 callback ：回调函数 fs.rmdirhttps://nodejs.org/dist/latest-v16.x/docs/api/fs.html#fsrmdirpath-options-callback fs.rmdirSync(path[, options]) 与 fs.rmdir 用法相同，区别在于，fs.rmdirSync 为同步方法，例如： 1234567891011const fs = require(&#x27;fs&#x27;)fs.rmdir(&#x27;test&#x27;,(err) =&gt; &#123; if(err) throw err console.log(&#x27;文件夹已删除&#x27;)&#125;)// orfs.rmdirSync(&#x27;test&#x27;)console.log(&#x27;文件夹已删除&#x27;) 只能删除空文件夹，若文件夹内有文件需要先循环删除文件夹内的文件，再删除文件夹。例如：12345678const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)for (const filename of fs.readdirSync(&#x27;test&#x27;)) &#123; fs.unlinkSync(path.resolve(&#x27;test&#x27;, filename))&#125;fs.rmdirSync(&#x27;test&#x27;) 脚手架编写 对上面的基础知识有了一些了解之后，就可以开始编写一个基本的前端脚手架了。 创建脚手架项目 我们需要创建一个 demo-cli 的脚手架项目文件夹同时运行如下命令： 1npm init [-y] 创建入口文件 index.js ，添加 init 方法，代码如下， 12345678async function init()&#123; // 具体的实现逻辑 &#125;// 运行该方法init().catch((e) =&gt; &#123; console.error(e)&#125;) 并根据自己的情况在 package.json 中添加相关命令。 需要在 index.js 加入 #!/usr/bin/env node ，用于指明该脚本文件需要用 node 来执行。 若在编辑器中无法自动提示 Node.js 相关方法，可在安装 @types/node 模块包。123npm i [--registry=https://registry.npmmirror.com] @types/node -D# 安装缓慢时，可设置临时源为淘宝源# --registry=https://registry.npmmirror.com 前置询问 通常脚手架运行是会提供一些配置或者模板选择的前置询问，此时我们需要用到 prompts 来实现这个功能，代码如下： 123npm i [--registry=https://registry.npmmirror.com] prompts -D# 安装缓慢时，可设置临时源为淘宝源# --registry=https://registry.npmmirror.com 在 index.js 中添加询问，目前只设置填写项目名，代码如下： 1234567891011121314151617181920const prompts = require(&#x27;prompts&#x27;)async function init()&#123; try &#123; const config = await prompts([ &#123; type: &#x27;text&#x27;, name: &#x27;projectName&#x27;, message: &#x27;请输入项目名?&#x27;, initial: &#x27;project&#x27;, validate: value =&gt; value ? true : &#x27;项目名不能为空&#x27; &#125; ]) const &#123; projectName &#125; = config console.log(projectName) // 输出项目 &#125; catch (cancelled) &#123; console.log(cancelled.message) process.exit(1) &#125;&#125; 编写核心方法 清空文件夹 emptyDir 方法 大致的显示思路如下：读取文件夹内的内容 -&gt; 判断内容是文件夹还是文件 -&gt; 若是文件调用 fs.unlink 或者 fs.unlinkSync 删除文件，若是文件夹再次调用之前的逻辑并调用 fs.rmdir 或者 fs.rmdirSync ， 代码如下： 1234567891011121314151617181920212223// 清空目录function emptyDir(dirPath)&#123; if(!fs.existsSync(dirPath))&#123; return false &#125; deleteDirFiles(dirPath)&#125;// 清空文件夹下具体方法function deleteDirFiles(dirPath)&#123; for (const fileName of fs.readdirSync(dirPath)) &#123; const fullPath = path.resolve(dirPath, fileName) if(fs.lstatSync(fullPath).isDirectory())&#123; // 读取文件夹内容，递归调通本方法 deleteDirFiles(fullPath) //删除目录 fs.rmdirSync(fullPath) &#125;else&#123; // 删除文件 fs.unlinkSync(fullPath) &#125; &#125;&#125; 将模板复制到目标目录 renderTemplat 方法 使用 fs.copyFile 或者 fs.copyFileSync 复制模板内的文件，若是文件夹则先创建相应的文件夹，在复制文件 。 1234567891011121314151617function renderTemplate(templatePath, targetPath)&#123; const status = fs.statSync(templatePath) // 判断是否文件夹 if(status.isDirectory())&#123; // 创建文件夹 fs.mkdirSync(targetPath, &#123; recursive: true &#125;) // 读取文件夹的内容递归本方法 for (const fileName of fs.readdirSync(templatePath)) &#123; const templateFullPath = path.resolve(templatePath, fileName) const targetFullPath = path.resolve(targetPath, fileName) renderTemplate(templateFullPath, targetFullPath) &#125; return &#125; // 文件直接复制到目标目录 fs.copyFileSync(templatePath, targetPath)&#125; 整体逻辑编写 大致逻辑：输入项目名称 -&gt; 判断目标文件夹是否存在，存在询问是否覆盖（清空目标文件夹），不存在创建文件夹 -&gt; 在目标文件夹内生成项目（脚手架内的模板项目复制到目标文件夹内）。代码如下： 12345678910111213141516171819202122232425262728293031323334353637async function init()&#123; try &#123; const config = await prompts([ &#123; type: &#x27;text&#x27;, name: &#x27;projectName&#x27;, message: &#x27;请输入项目名?&#x27;, initial: &#x27;project&#x27;, validate: value =&gt; value ? true : &#x27;项目名不能为空&#x27; &#125; ]) const &#123; projectName &#125; = config const root = process.cwd() // 目标根目录 const target = path.join(root, projectName) // 目标路径 const templateRoot = path.resolve(__dirname, &#x27;template&#x27;) // 模板绝对路径 if(fs.existsSync(target))&#123; const &#123; overWrite &#125; = await prompts([ &#123; type: &#x27;toggle&#x27;, name: &#x27;overWrite&#x27;, message: &#x27;项目已存在，是否覆盖？&#x27;, initial: true, active: &#x27;yes&#x27;, inactive: &#x27;no&#x27; &#125; ]) if(overWrite) emptyDir(target) &#125;else&#123; fs.mkdirSync(target) &#125; renderTemplate(templateRoot, target) console.log(&#x27;项目生成成功！&#x27;) &#125; catch (cancelled) &#123; console.log(cancelled.message) process.exit(1) &#125;&#125; 本文只是实现了一个简单的前端脚手架，真实情况下，前端脚手架还应可以选择相关配置，并根据所选择的配置生成项目。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://yunbochen.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"nodejs","slug":"笔记/nodejs","permalink":"https://yunbochen.github.io/categories/%E7%AC%94%E8%AE%B0/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://yunbochen.github.io/tags/nodejs/"},{"name":"file","slug":"file","permalink":"https://yunbochen.github.io/tags/file/"},{"name":"node","slug":"node","permalink":"https://yunbochen.github.io/tags/node/"},{"name":"脚手架","slug":"脚手架","permalink":"https://yunbochen.github.io/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"}],"author":"Rainbow"},{"title":"类的装饰器","slug":"study/typescript/高级/类的装饰器","date":"2021-12-13T00:00:00.000Z","updated":"2022-01-24T03:33:13.998Z","comments":true,"path":"study/typescript/高级/类的装饰器.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E9%AB%98%E7%BA%A7/%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8.html","excerpt":"","text":"装饰器还处于 实验性 的阶段，需要在 tsconfig.json 中开启，才不会报错。12345&#123; &quot;experimentalDecorators&quot;: true, &quot;emitDecoratorMetadata&quot;: true, //... other config&#125; 装饰器 装饰器 是一种特殊类型的声明，能够被附加到类声明、方法、属性或参数上，其本身是一个函数。使用 @ 符号，例如： 12345678910function demoDecorators (constructor: any) &#123; console.log(&#x27;装饰器&#x27;)&#125;@demoDecoratorsclass Demo&#123;&#125;const demo = new Demo()// 输出装饰器 📌装饰器 是在代码编译时是发生的（ JavaScript 执行时的编译阶段，不是 Typescript 编译），并不在代码运行时。 函数柯里化解决参数问题： 12345function demoDecorators (param: string) &#123; return function()&#123; // 真正的装饰器 // 装饰器的逻辑 &#125;&#125; 装饰器的种类 类装饰器 ：应用于类构造函数，其参数是类的 构造函数 constructor 。 1234567891011function demoDecorators (constructor: any) &#123; constructor.prototype.getDemo = () =&gt; &#123; console.log(&#x27;demo&#x27;) &#125;&#125;@demoDecoratorsclass Demo&#123;&#125;const demo = new Demo()demo.getDemo() 上述代码放入真实的编辑器（比如：vscode）中会报错，getDemo 是通过 装饰器 挂载到 constructor 上的，此时 constructor 类型为 any ，而 demo 的 类型为 Demo ，两者类型不同，所以无法找到该方法。利用 as 将 类型改为 any : 1( demo as any ).getDemo() 使用 泛型 对类进行扩展： 123456789101112131415161718192021function FullNameDecorator&lt;T extends new (...args: any[]) =&gt; any&gt;(first: string) &#123; return function (constructor: T) &#123; return class extends constructor&#123; getFullName()&#123; return first + this.name &#125; &#125; &#125;&#125;@FullNameDecorator(&#x27;张&#x27;)class Person&#123; name: string constructor(name: string)&#123; this.name = name &#125;&#125;const demo = new Person(&#x27;三&#x27;)console.log((demo as any ).getFullName()) 可对 FullNameDecorator 进行改造，使其可以不用 as 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function FullNameDecorator&lt;T extends new (...args: any[]) =&gt; any&gt;(first: string) &#123; return function (constructor: T) &#123; return class extends constructor&#123; getFullName()&#123; return first + this.name &#125; &#125; &#125;&#125;const Person = FullNameDecorator(&#x27;张&#x27;)(class &#123; name: string constructor(name: string)&#123; this.name = name &#125;&#125;)const demo = new Person(&#x27;三&#x27;)console.log(demo.getFullName())2. `方法装饰器` ：被应用到方法的属性描述符上，可以用来监视，修改或者替换方法定义。 方法装饰会在运行时传入三个参数： - 对于静态方法来说是类的构造函数，对于普通方法是类的原型对象 - 成员的名字 - 成员的属性描述符 :pushpin: 与 [`Object.defineProperty()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 内的三个参数含义相同。 ```typescript function GetNameDecorator(target: any, key: string, descriptor: PropertyDescriptor) &#123; descriptor.value = () =&gt; &#x27;descriptor&#x27; &#125; class Demo &#123; name: string constructor(name: string) &#123; this.name = name &#125; @GetNameDecorator getName()&#123; return this.name &#125; &#125; const demo = new Demo(&#x27;张三&#x27;) console.log(demo.getName()) // 输出 descriptor 访问器装饰器 ：被应用到访问器的属性描述符上，可以用来监视，修改或者替换访问器定义。 同 方法装饰器 一样，运行时也会传入三个参数，含义也相同。 1234567891011121314151617181920212223function VisitDecorator(target: any, key: string, descriptor: PropertyDescriptor) &#123; descriptor.writable = false&#125;class Demo &#123; private _name: string constructor(name: string) &#123; this._name = name &#125; get name()&#123; return this._name &#125; @VisitDecorator set name(name: string)&#123; this._name = name &#125;&#125;const demo = new Demo(&#x27;张三&#x27;)demo.name = &#x27;123123&#x27;console.log(demo.name)// error , 因为设置了 descriptor.writable = false 不可修改 属性装饰器 ：属性装饰器表达式会在运行时当作函数被调用。 属性装饰会传入2个参数： 对于静态方法来说是类的构造函数，对于普通方法是类的原型对象 成员的名字 📌 与 Object.defineProperties() 内的三个参数含义相同。 12345678910111213function PropsDecorator(value: string)&#123; return function(target: any, key: string) &#123; target[key] = value &#125;&#125;class Demo &#123; @PropsDecorator(&#x27;张三&#x27;) name: string | undefined&#125;const demo = new Demo()console.log(demo.name) // 张三 与 方法装饰器 相比缺少一个 成员的属性描述符 的属性，我们可以在 装饰器 内定义这个属性： 1234567891011121314function PropsDecorator(target: any, key: string): any&#123; const descriptor: PropertyDescriptor = &#123; writable: false &#125; return descriptor&#125;class Demo &#123; @PropsDecorator name: string = &#x27;张三&#x27;&#125;const demo = new Demo()console.log(demo.name) // 报错，属性设置为只读 参数装饰器 ：参数装饰器表达式会在运行时当作函数被调用 参数修饰传入三个参数： 对于静态方法来说是类的构造函数，对于普通方法是类的原型对象 参数名 参数的索引 123456789101112function ParamsDecorator(target: any, methodName: string, index: number)&#123; console.log(target, methodName, index)&#125;class Demo &#123; getInfo(@ParamsDecorator name: string, age: number)&#123; console.log(name, age) &#125;&#125;const demo = new Demo()demo.getInfo(&#x27;张三&#x27;, 12)","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"高级","slug":"高级","permalink":"https://yunbochen.github.io/tags/%E9%AB%98%E7%BA%A7/"}],"author":"Rainbow"},{"title":"import 对应的模块化","slug":"study/typescript/进阶/import对应的模块化","date":"2021-12-10T00:00:00.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"study/typescript/进阶/import对应的模块化.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E8%BF%9B%E9%98%B6/import%E5%AF%B9%E5%BA%94%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96.html","excerpt":"","text":"声明文件 *.d.ts 声明文件 *.d.ts 用于描述 Javascript 模板内导出的接口类型信息。 通常情况下，我们可以通过 tsconfig.json 的相关配置，会在编译的时候自动生成 *.d.ts 文件。以下几种情况需要自己定义： 引入的第三方包没有声明类型文件 一般编辑器会提示缺少 @types/xxxx 的错误，需要自己去安装一下相应的插件包。 通过 CDN 引入的工具库 挂载一些全局的方法，如果在ts中，直接使用方法的话，会提示错误，此时需要引入全局的类型声明。 如何编写声明文件 *.d.ts 使用 declare 关键词来定义类型。 定义全局变量 var ： 1declare var demo: (params: () =&gt; void) =&gt; void 定义全局函数 function： 1declare function demo (params: () =&gt; void) : void 定义对象、类、命名空间 namesapce ： 1234567declare namespace demo&#123; namespace fn&#123; class init&#123;&#125; &#125;&#125;// new demo.fn.init 定义模块 module ： 123declare module demo &#123; ...&#125; 需要用到模块中的方法是，需要 export 。","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"进阶","slug":"进阶","permalink":"https://yunbochen.github.io/tags/%E8%BF%9B%E9%98%B6/"}],"author":"Rainbow"},{"title":"命名空间 namespace","slug":"study/typescript/进阶/namespace","date":"2021-12-10T00:00:00.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"study/typescript/进阶/namespace.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E8%BF%9B%E9%98%B6/namespace.html","excerpt":"","text":"命名空间 可以很好的解决重名的问题。 命名空间 定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的。这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中。 关键词 namespace ，基础用法： 123namespace demo&#123; ....&#125; 使用了 命名空间 之后，无法像之前一样直接就可调用 命名空间 内的函数、类型，需要在相应的地方加上 export ，才可使用。例如： 123456789101112namespace demo &#123; interface DemoType&#123; name: string, age: number &#125; demoFnc(): void class DemoClass&#123;&#125;&#125;const demoType = demo.DemoTypedemo.demoFnc()new demo.demo() 使用下面的方式引入别的 命名空间 ，编辑器就能提供语法提示。 1/// &lt;reference path = &quot;xxx.ts&quot; /&gt; 将代码抽离变成不同模块的 命名空间 时，可修改 tsconfig.josn 内 outFile 配置项，编译成一个文件。 需要将 tsconfig.josn 内 module 改为 amd 。","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"进阶","slug":"进阶","permalink":"https://yunbochen.github.io/tags/%E8%BF%9B%E9%98%B6/"}],"author":"Rainbow"},{"title":"函数泛型","slug":"study/typescript/进阶/函数泛型","date":"2021-12-09T00:00:00.000Z","updated":"2022-01-24T03:33:13.998Z","comments":true,"path":"study/typescript/进阶/函数泛型.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E8%BF%9B%E9%98%B6/%E5%87%BD%E6%95%B0%E6%B3%9B%E5%9E%8B.html","excerpt":"","text":"泛型 指的是泛指的类型，具体的类型未知，可以是任何的类型。 函数中使用泛型 例如： 123function join(a: string | number, b: string | number)&#123; return `$&#123;a&#125;$&#123;b&#125;`&#125; 期望 join 函数中任一参数的类型确定之后，其余参数都为这个类型，那么可以使用 泛型 ，将函数改造： 123456function join&lt;T&gt;(a: T, b: T)&#123; return `$&#123;a&#125;$&#123;b&#125;`&#125;join&lt;string&gt;(1,2) // 报错， 当前 a、b 为 string 类型join&lt;number&gt;(1,2) // 正确 泛型 还有很多用法： 数组类型结合使用 12345678910function map&lt;T&gt;(params: T[])&#123; return params&#125;// orfunction map&lt;T&gt;(params: Array&lt;T&gt;)&#123; return params&#125;map&lt;number&gt;([1]) Array 类型本身就是 泛型 的一种。例如：String[] 和 Array&lt;string&gt; 本质是一样都代表字符串数组。 定义多个泛型 12345function join&lt;T, S&gt;(a: T, b: S)&#123; return `$&#123;a&#125;$&#123;b&#125;`&#125;join&lt;number, string&gt;(1,&#x27;2&#x27;) 若直接写 join('1', 2) ，TypeScript 会自行去推断出 泛型 内的类型。 类中使用泛型 例如： 123456789101112class DataManage&#123; private data: string[] constructor(data: string[])&#123; this.data = data &#125; getItem(index: number):string&#123; return this.data[index] &#125;&#125;const dataManage = new DataManage([&#x27;1&#x27;])console.log(dataManage.getItem(0)) new DataManage 时，只能传入 string[] 类型，如果需要不单单能传入 string[] 类型，还要传入 number[] 类型，最简单的改造方法是使用 联合类型 ，但如果参数类型需要根据传入的参数自行去定义，或者想写一个通用的，就可以使用 泛型 。改造之后的 DataManage ： 123456789101112131415class DataManage&lt;T&gt;&#123; private data: T[] constructor(data: T[])&#123; this.data = data &#125; getItem(index: number):T&#123; return this.data[index] &#125;&#125;const stringManage = new DataManage&lt;string&gt;([&#x27;1&#x27;])const numberManage = new DataManage&lt;number&gt;([1])console.log(stringManage.getItem(0)) // stringconsole.log(numberManage.getItem(0)) // number 继承 有时我们需要泛型是自己定义的类型，可以使用 extends 关键词去继承。 1234567891011121314151617interface Item&#123; name: string&#125;class DataManage&lt;T extends Item&gt;&#123; private data: T[] constructor(data: T[])&#123; this.data = data &#125; getItem(index: number): string&#123; return this.data[index].name &#125;&#125;const stringManage = new DataManage([&#123; name: &#x27;111&#x27;&#125;]) 约束 使用 泛型 时，可以设置任何类型，但往往可能只能传入特定的几种类型时，就需要用到 泛型约束。 extends ：继承一个联合类型 1234567891011121314class DataManage&lt;T extends string | number&gt;&#123; private data: T[] constructor(data: T[])&#123; this.data = data &#125; getItem(index: number): T&#123; return this.data[index] &#125;&#125;const numberManage = new DataManage([1])const stringManage = new DataManage([&#x27;1&#x27;])const booleanManage = new DataManage([true]) // 报错，不支持传入boolean keyof ：与 extends 配合使用，进行 类型保护 1234567891011121314151617181920212223242526interface Person &#123; name: string age: number gender: string&#125;class Teacher &#123; private _info: Person constructor(info: Person)&#123; this._info = info &#125; getInfo&lt;T extends keyof Person&gt;(key: T): Person [T]&#123; return this._info[key] &#125;&#125;const teacher = new Teacher(&#123; name: &#x27;demo&#x27;, age: 20, gender: &#x27;male&#x27;&#125;)const teacherName = teacher.getInfo(&#x27;name&#x27;)// string 类型const age = teacher.getInfo(&#x27;age&#x27;) // number 类型const gender = teacher.getInfo(&#x27;gender&#x27;) // string 类型const other = teacher.getInfo(&#x27;other&#x27;) //error 类型“&quot;other&quot;”的参数不能赋给类型“keyof Person”的参数。 声明类型 泛型 还能作为一个具体的类型注解 12345function hello&lt;T&gt;(param: T) &#123; return param&#125;const func: &lt;T&gt;(param: T) =&gt; T = hello 更多使用方法，请查看文档。 相关文档https://www.typescriptlang.org/docs/handbook/2/generics.html","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"进阶","slug":"进阶","permalink":"https://yunbochen.github.io/tags/%E8%BF%9B%E9%98%B6/"}],"author":"Rainbow"},{"title":"枚举类型 Enum","slug":"study/typescript/进阶/枚举类型 Enum","date":"2021-12-09T00:00:00.000Z","updated":"2022-01-24T03:33:13.998Z","comments":true,"path":"study/typescript/进阶/枚举类型 Enum.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E8%BF%9B%E9%98%B6/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%20Enum.html","excerpt":"","text":"枚举 是一种组织相关值集合的方法。 123456789101112enum Status &#123; OFFLINE, ONLINE, DELETE&#125;function getResult(status: Number) &#123; return status === Status.OFFLINE ? &#x27;offline&#x27; : status === Status.ONLINE ? &#x27;online&#x27; : &#x27;delete&#x27;&#125;getResult(0) // offlinegetResult(1) // onlinegetResult(2) // delete 枚举值 默认从 0 开始依次加 1，也可以自己定义枚举值的值， 例如： 1234567891011121314enum Status &#123; OFFLINE, ONLINE = 3, DELETE&#125;function getResult(status: Number) &#123; return status === Status.OFFLINE ? &#x27;offline&#x27; : status === Status.ONLINE ? &#x27;online&#x27; : &#x27;delete&#x27;&#125;getResult(0) // offlinegetResult(3) // onlinegetResult(2) // delete 枚举值 对应的 标题 和 值 可以相关使用，例如： 12345678enum Status &#123; OFFLINE, ONLINE, DELETE&#125;Status.OFFLINE // 0Status[0] // OFFLINE","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"进阶","slug":"进阶","permalink":"https://yunbochen.github.io/tags/%E8%BF%9B%E9%98%B6/"}],"author":"Rainbow"},{"title":"联合类型和类型保护","slug":"study/typescript/进阶/联合类型和类型保护","date":"2021-12-09T00:00:00.000Z","updated":"2022-01-24T03:33:13.998Z","comments":true,"path":"study/typescript/进阶/联合类型和类型保护.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E8%BF%9B%E9%98%B6/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4.html","excerpt":"","text":"联合类型 对于一个变量或参数有时不单单是单一类型，有可能是多个类型中的一个，这时，可以使用 联合类型 。用 | 符号来分割类型，例如： 123456let demo: string | number// 数字类型demo = 12// 字符串类型demo = &#x27;test&#x27; 若类型为自己定义的 interface 或 type ，只能使用显示类型中共同拥有的属性，其他属性会报错，例如： 12345678910111213interface Bird&#123; fly: boolean flyTo(): void&#125;interface Dog&#123; fly: boolean runTo(): void&#125;function trainAnimal(animal: Bird | Dog) &#123; console.log(animal.fly) // 只能使用 fly 这个属性&#125; 类型保护 上述 联合类型 的例子中，Bird 和 Dog 两个接口都要自己独有的方法，在 trainAnimal 方法中，想要使用必须进行 类型保护 。类型保护 有好几种方式：类型断言 、in 类型断言 ：使用 as 关键词，对 变量 或 参数 进行类型断言，让编译器知道当前具体是什么类型。 1234567function trainAnimal(animal: Bird | Dog) &#123; if(animal.fly)&#123; (animal as Bird).flyTo() &#125;else&#123; (animal as Dog).runTo() &#125;&#125; in ：使用 in 判断 属性 是否在 变量 或 参数 ，编译器就可知道当前是什么类型。 1234567function trainAnimal(animal: Bird | Dog) &#123; if(&#x27;flyTo&#x27; in animal)&#123; animal.flyTo() &#125;else&#123; animal.runTo() &#125;&#125; typeof ：使用 typeof 判断 变量 或 参数 的类型。 1234567function add(a: string | number, b: string | number) &#123; if(typeof a === &#x27;string&#x27; &amp;&amp; typeof b === &#x27;string&#x27;)&#123; return a + b &#125; return `$&#123;a&#125;$&#123;b&#125;`&#125; instanceof ：使用 instanceof 判断 变量 或 参数 的类型。 只能判断 class 定义的类型 12345678910class NumberObj &#123; count: number&#125;function add(a: NumberObj | number, b: NumberObj | number) &#123; if(a instanceof NumberObj &amp;&amp; b instanceof NumberObj)&#123; return a.count + b.count &#125; return 0&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"进阶","slug":"进阶","permalink":"https://yunbochen.github.io/tags/%E8%BF%9B%E9%98%B6/"}],"author":"Rainbow"},{"title":"tsconfig.json 配置说明","slug":"study/typescript/进阶/tsconfig配置说明","date":"2021-12-08T00:00:00.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"study/typescript/进阶/tsconfig配置说明.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E8%BF%9B%E9%98%B6/tsconfig%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.html","excerpt":"","text":"tsconfig.json 是 TypeScript 编译器的配置文件，会根据该文件的配置进行对应的编译和检查。 文件选项配置 files ：表示编译需要编译的单个文件列表，例如： 123456&#123; &quot;files&quot;: [ &quot;src/demo.ts&quot;, &quot;src/demo2.ts&quot; ],&#125; 若 src 文件中有 demo1.ts 、demo2.ts 、demo3.ts 三个文件，由于 tsconfig.json 文件进行了上面的配置，所以运行 tsc 时，只会编译 demo1.ts 、demo2.ts 这两个文件。 include ：表示编译需要编译的文件或目录，例如： 12345&#123; &quot;include&quot;: [ &quot;src/demo2&quot;, //编译 src 目录下的 demo2 文件夹中的所有文件 ],&#125; 还能使用正则匹配来配置通用的文件夹路径，例如： 12345678&#123; &quot;include&quot;: [ &quot;src&quot;, //编译 src 目录下所有文件夹中的所有文件 &quot;src/*&quot;, //编译 src 目录下所有一级文件夹中的所有文件 &quot;src/*/*&quot;, //编译 src 目录下所有二级文件夹中的所有文件 ... //其他正则路径 ],&#125; exclude ：表示编译器需要排除的文件或文件夹（默认排除 node_modules 文件夹），例如： 12345&#123; &quot;exclude&quot;: [ &quot;src/demo2&quot;, //不编译 src 目录下的 demo2 文件夹中的所有文件 ],&#125; 同 include 一样，支持正则匹配路径。 extends ：引入其他配置文件，继承配置，例如： 1234&#123; // 把基础配置抽离成tsconfig.base.json文件，然后引入 &quot;extends&quot;: &quot;./tsconfig.base.json&quot;&#125; 编译选项配置 compilerOptions 编译器根据该节点下的配置进行对应的编译 只举例常用的配置，其他配置详见文档。 配置文件https://www.typescriptlang.org/tsconfig#compilerOptions target： 编译之后 .js 文件 的语言版本 12345678910// demo.tsconst demo: string = &#x27;1&#x27;// 编译之后的 demo.js// target: &quot;es2015&quot;const demo = &#x27;1&#x27;;// target: &quot;es5&quot;var demo = &#x27;1&#x27;; lib ：TypeScript 需要引用的库，即声明文件。 module ：编译之后 .js 文件 的代码标准 CommonJS UMD AMD System ESNext ES2020 ES2015/ES6 … outDir ：编译生成的文件夹 allowJs : 是否允许编译器编译 JS 、JSX 文件 true 允许 false 不允许 checkJs ：是否允许在 JS 文件中报错，通常与 allowJs 一起使用。 true 允许 需设置 allowJs: true false 不允许 strict ：是否使用严格模式 true 使用严格模式，所有类型检查的设置都校验。 false 不使用严格模式，可根据自己的使用习惯或实际情况配置类型检查。 初学者或还没熟练使用 TypeScript 的，建议使用严格模式。 noImplicitAny ：是否允许隐式 any 类型 true 不允许隐式 any 类型 false 允许隐式 any 类型 1234567891011// noImplicitAny: falsefunction demo(params) &#123; console.log(params.a)&#125;// 不会报错// noImplicitAny: truefunction demo(params) &#123; console.log(params.a)&#125;// 会报参数 params 隐式具有“any”类型的错误 strictNullChecks ：是否允许把 null 、undefined 赋值给其他类型的变量 true 不允许把 null 、undefined 赋值给其他类型的变量 false 允许把 null 、undefined 赋值给其他类型的变量 123456789interface Demo&#123; a: string b?: number&#125;function printDemo(demo: Demo): void &#123; console.log(demo.b.toString()) // strictNullChecks: true 会报 对象可能为“未定义”。&#125; strictFunctionTypes ：是否允许函数参数双向协变 true 不允许函数参数双向协变 false 允许函数参数双向协变 123456789101112function demo (param: string): void&#123; console.log(param)&#125;type stringOrNumberFn = ( param: string | number ) =&gt; voidconst fnc: stringOrNumberFn = demo// strictFunctionTypes: true //不能将类型“(param: string) =&gt; void”分配给类型“stringOrNumberFn”。// 参数“param”和“param” 的类型不兼容。// 不能将类型“string | number”分配给类型“string”。// 不能将类型“number”分配给类型“string”。 strictBindCallApply ：是否对 bind 、call 、apply 严格检查 true 对 bind 、call 、apply 严格检查 false 对 bind 、call 、apply 不严格检查 1234567function demo (param: string): number&#123; return parseInt(param)&#125;const fnc = demo.call(this, false)// strictBindCallApply: true 会报类型“boolean”的参数不能赋给类型“string”的参数。// strictBindCallApply: false 不报错，返回类型为 any strictPropertyInitialization ：类的实例属性是否必须初始化 true 必须实例化 必须配置 strictNullChecks: true 才能设置设置该项为 true false 不必实例化 1234567891011class Demo&#123; a = 1 b: string c: boolean constructor() &#123; this.b = &#x27;1&#x27; &#125;&#125;// strictPropertyInitialization: true// 报属性 c 没有初始化表达式，且未在构造函数中明确赋值的错误 noUnusedLocals ：检查是否有未用到的变量 只提示不报错 true 检查 false 不检查 12345678function demo(): void &#123; const a = 1; const b = 2 console.log(a)&#125;// noUnusedLocals: true// 提示变量 b 未使用 noUnusedParameters ：检查是有未使用的函数参数 只提示不报错 true 检查 false 不检查 123456function demo(a: number, b: number): void &#123; console.log(a)&#125;// noUnusedParameters: true// 提示参数 b 未使用 工程引用配置 references 指定工程引用依赖 相关文档https://www.typescriptlang.org/docs/handbook/project-references.html","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"进阶","slug":"进阶","permalink":"https://yunbochen.github.io/tags/%E8%BF%9B%E9%98%B6/"}],"author":"Rainbow"},{"title":"抽象类","slug":"study/typescript/基础/抽象类","date":"2021-12-07T00:00:00.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"study/typescript/基础/抽象类.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E5%9F%BA%E7%A1%80/%E6%8A%BD%E8%B1%A1%E7%B1%BB.html","excerpt":"","text":"什么是抽象类 抽象类 作为其它派生类的基类使用。它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。例如： 1234abstract class Geom &#123; width: number; abstract getArea(): number&#125; 抽象类 只能被 继承 不能 new ，抽象类定义的方法 需要自己在类中实现： 123456789abstract class Geom &#123; abstract getArea(): number&#125;class Circle extends Geom&#123; getArea()&#123; return 123 &#125;&#125; 与接口的区别 抽象类里面可以有方法的实现，但是接口完全都是抽象的，不存在方法的实现。 123456789101112abstract class Base1 &#123; getName()&#123; return &#x27;111&#x27; &#125; abstract getAge(): number&#125;interface Base2 &#123; getName(): string, getAge(): number&#125; 子类只能继承一个抽象类，而接口可以被多个实现。 12345678910111213141516171819202122232425262728293031323334353637abstract class Base1 &#123; getName()&#123; return &#x27;111&#x27; &#125; abstract getAge(): number&#125;abstract class Base3 &#123; abstract getSex(): string&#125;class AbstractChild extends Base1, Base3&#123; // 会报错，子类只能继承抽象类 getAge()&#123; return 1 &#125;&#125;interface Base2 &#123; getName(): string, getAge(): number&#125;interface Base4 &#123; getSex(): number&#125;class InterfaceChild implements Base2, Base4&#123; // 接口可以被多个实现 getName()&#123; return &#x27;1&#x27; &#125; getAge()&#123; return 1 &#125; getSex()&#123; return 2 &#125;&#125; 抽象方法可以是 public 、protected ，但是接口只能是默认的 public 。 123456789abstract class Base1 &#123; abstract getAge(): number protected abstract width: number&#125;interface Base2 &#123; getAge(): number, width(): number&#125; 抽象类可以有构造器，而接口不能有构造器。 12345678abstract class Base1 &#123; abstract getAge(): number constructor()&#123;&#125;&#125;interface Base2 &#123; getAge(): number,&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"基础","slug":"基础","permalink":"https://yunbochen.github.io/tags/%E5%9F%BA%E7%A1%80/"}],"author":"Rainbow"},{"title":"类的访问类型和构造器","slug":"study/typescript/基础/类的访问类型和构造器","date":"2021-12-07T00:00:00.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"study/typescript/基础/类的访问类型和构造器.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%9E%84%E9%80%A0%E5%99%A8.html","excerpt":"","text":"访问类型 类有 private 、protected 、public 三种访问类型。 public : 默认访问类型，允许在类的内外被调用。 12345678910111213class Person &#123; name: string sayHi()&#123; return &#x27;Hi&#x27; &#125;&#125;const person = new Person()person.name = &#x27;hello&#x27;console.log(person.name)// helloperson.sayHi()// Hi private : 允许在类内被调用。 12345678910class Person &#123; private name: string sayHi()&#123; this.name = &#x27;test&#x27; return &#x27;Hi&#x27; &#125;&#125;const person = new Person()person.name = &#x27;hello&#x27; // 报错，name为内部属性不能再外部被调用 protected : 允许在类内及继承的子类中使用。 1234567891011121314class Person &#123; protected name: string sayHi()&#123; this.name = &#x27;test&#x27; return &#x27;Hi&#x27; &#125;&#125;class Teacher extends Person&#123; teach()&#123; this.name = &#x27;test&#x27; // 因为 Person 中的 name 属性为 protected 可直接 this.name 调用 return `$&#123;this.name&#125; teach` &#125;&#125; 构造器 constructor constructor 在 new 一个新对象时，会自动执行。一般在 new 新对象时将参数传递给类。例如： 12345678class Person&#123; public name: string constructor(name: string)&#123; this.name = name &#125;&#125;const person = new Person(&#x27;test&#x27;)console.log(person.name) // test 或者还可以简化写法 （一般不推荐）： 1234567class Person&#123; constructor(public name: string)&#123;&#125;&#125;const person = new Person(&#x27;test&#x27;)console.log(person.name) super 关键词，如果 super 在子类的某一属性中调用则代表父类的 this ，若在 constructor 中则需要使用 super() ，代表调用父类的构造函数。 123456789101112131415class Person&#123; constructor(public name: string)&#123;&#125;&#125;class Teacher extends Person&#123; constructor(public age: number)&#123; super(&#x27;test&#x27;) &#125;&#125;const teacher = new Teacher(26)console.log(teacher.name) // testconsole.log(teacher.age) // 26","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"基础","slug":"基础","permalink":"https://yunbochen.github.io/tags/%E5%9F%BA%E7%A1%80/"}],"author":"Rainbow"},{"title":"静态属性、Setter、Getter","slug":"study/typescript/基础/静态属性、Setter、Getter","date":"2021-12-07T00:00:00.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"study/typescript/基础/静态属性、Setter、Getter.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E5%9F%BA%E7%A1%80/%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E3%80%81Setter%E3%80%81Getter.html","excerpt":"","text":"静态属性、Setter、Getter 类 中的某个属性定义为 private 访问类型时，外部无法访问，这时我们需要通过 setter 和 getter 处理这些私有的属性使其能被外部访问，一般私有属性以 _ 开头。例如： 12345678910111213class Person&#123; constructor(private _name: string)&#123;&#125; get name()&#123; return this._name + &#x27;name&#x27; &#125; set name(name: string)&#123; const realName = name + &#x27;name&#x27; this._name = realName &#125;&#125;const person = new Person(&#x27;test&#x27;)console.log(person.name) // testname 实战：单例模式的类 单例模式 指只允许存在一个实例，不能 new 多个实例，所以首先需要将 constructor 私有化： 12345class Demo&#123; private constructor() &#123;&#125;&#125;const demo = new Demo() // 报错，constructor为私有的，无法 new constructor 私有化后，外部需要访问就需要使用 static 关键词向外部暴露一个 getInstance 方法： 123456class Demo&#123; private constructor() &#123;&#125; static getInstance()&#123; return new Demo() &#125;&#125; 上述代码，依然不是 单例模式 ，仍可通过 Demo.getInstance() 创建多个实例，所以我们需要再使用 static 定义一个 私有静态属性 instance 来判断是否创建过实例，例如： 12345678910class Demo&#123; private static instance: Demo private constructor() &#123;&#125; static getInstance()&#123; if(!this.instance)&#123; this.instance = new Demo() &#125; return this.instance &#125;&#125; 这样一个简单的 单例模式 的类就创建好了。","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"基础","slug":"基础","permalink":"https://yunbochen.github.io/tags/%E5%9F%BA%E7%A1%80/"}],"author":"Rainbow"},{"title":"interface 接口","slug":"study/typescript/基础/interface接口","date":"2021-12-06T00:00:00.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"study/typescript/基础/interface接口.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E5%9F%BA%E7%A1%80/interface%E6%8E%A5%E5%8F%A3.html","excerpt":"","text":"interface 是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。 基本使用方法 使用方法如下： 1234567891011121314151617interface Person &#123; name: string, sayHi(): string&#125;const getPersonName = (person: Person): void =&gt; &#123; console.log(person.name)&#125;const person = &#123; name: &#x27;test1&#x27;, seyHi: () =&gt; &#x27;test1&#x27;&#125;getPersonName(person)console.log(person.seyHi) 接口 中的某些参数可有可无，可在参数后面加上 ? ，例如： 1234567891011121314151617181920interface Person &#123; name: string, age?: number&#125;const getPersonName = (person: Person): void =&gt; &#123; console.log(person.name)&#125;const person = &#123; name: &#x27;test1&#x27;&#125;getPersonName(person)const person1 = &#123; name: &#x27;test2&#x27;, age: 20&#125;getPersonName(person1) 接口 中有已知参数和未知参数，可以使用如下的方面来定义： 12345678910111213141516interface Person &#123; name: string, age?: number, [propName: string]: any&#125;const getPersonName = (person: Person): void =&gt; &#123; console.log(person.name)&#125;const person = &#123; name: &#x27;test2&#x27;, age: 20, sex: &#x27;man&#x27;&#125;getPersonName(person) 可为方法定义类型， 例如： 12345interface SayHi &#123; (word: string): string&#125;const sayHi: SayHi = (word: string) =&gt; word 在类中使用 使用方法： 1234567891011interface Person &#123; name: string, sayHi(): string&#125;class User implements Person&#123; name = &#x27;test&#x27; sayHi() &#123; return `Hi! $&#123;this.name&#125;` &#125; &#125; 继承 继承指的是 接口 可通过其他接口来扩展，并且可以继承多个 接口 。关键词为 extends 。 单个接口继承，如下： 123456789101112131415161718192021interface Person &#123; name: string, [propName: string]: any, sayHi(): string&#125;interface Teacher extends Person&#123; className: string, teach(): string&#125;const teacher: Teacher = &#123; name: &#x27;张三&#x27;, className: &#x27;一班&#x27;, sayHi() &#123; return `Hi! $&#123;this.name&#125;` &#125;, teach()&#123; return &#x27;数学&#x27; &#125; &#125; 多个接口继承，如下： 1234567891011121314151617181920212223242526interface Person &#123; name: string, [propName: string]: any, sayHi(): string&#125;interface Sex&#123; sex: &#x27;男&#x27; | &#x27;女&#x27;&#125;interface Teacher extends Person, Sex&#123; className: string, teach(): string&#125;const teacher: Teacher = &#123; name: &#x27;张三&#x27;, className: &#x27;一班&#x27;, sex: &#x27;男&#x27;, sayHi() &#123; return `Hi! $&#123;this.name&#125;` &#125;, teach()&#123; return &#x27;数学&#x27; &#125; &#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"基础","slug":"基础","permalink":"https://yunbochen.github.io/tags/%E5%9F%BA%E7%A1%80/"}],"author":"Rainbow"},{"title":"函数相关类型","slug":"study/typescript/基础/函数相关类型","date":"2021-12-06T00:00:00.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"study/typescript/基础/函数相关类型.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9E%8B.html","excerpt":"","text":"TypeScript 因为是 JavaScript 的超集，所以定义函数的方式是完全一致。 有的时候 TypeScript 推断出来的函数类型不是想要的类型，就需要我们对函数进行类型注解，例如： 12345678910function totalNum(first, second)&#123; return first + second + &#x27;&#x27;&#125;const total = totalNum(1, 2)// 这种情况下，TypeScript 会推断 total 为 string 类型，但我们其实需要 number 类型，就需要对 totalNum 进行类型注解function totalNum(first, second): number&#123; return first + second&#125; 函数有时需要传递 解构 的参数，我们需要： 12345function totalNum(&#123; first, second &#125;: &#123; first: number, second: number &#125;): number&#123; return first + second &#125;const total = totalNum(&#123; first: 1, second: 2 &#125;)","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"基础","slug":"基础","permalink":"https://yunbochen.github.io/tags/%E5%9F%BA%E7%A1%80/"}],"author":"Rainbow"},{"title":"基础静态类型和对象类型","slug":"study/typescript/基础/基础静态类型和对象类型","date":"2021-12-06T00:00:00.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"study/typescript/基础/基础静态类型和对象类型.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B.html","excerpt":"","text":"在 TypeScript 中静态类型分为两种：基础静态类型、对象类型。 基础静态类型 基础静态类型 只需在声明的变量后加上 :对应类型 即可，例如： 12const num: number = 1233 // num 为数字类型const name: string = &#x27;haha&#x27; // name 为 字符串类型 常用的基础静态类型：string 、number 、null 、undefined ，symbol 、boolean 、void 。 对象类型 对象类型 在 TypeScript 中大致为以下一种： 对象类型 12345678// 对象类型const person: &#123; name: string, age: number&#125; = &#123; name: &#x27;test&#x27;, age: 20&#125; 数组类型 12// 数组类型const nameList: String[] = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;] 类类型 123// 类类型class Person&#123;&#125;const user = new Person() 函数类型 1234// 函数类型const demoFn: () =&gt; string = () =&gt; &#123; return &#x27;haha&#x27;&#125; 类型推断 在没有为变量声明类型时，TypeScript 会自行去推断出当前变量的类型，例如： 123456let count: number// count 为 number 类型count = 123 // 变量 str 没有声明类型，TypeScript则会根据上下文自行推断出 str 为 string 类型let str = &#x27;hello&#x27; 类型注解 有时候 TypeScript 也无法推断出变量的类型时，就需要使用 类型注解 解决这个问题，例如： 12345678910111213function totalNum(first, second)&#123; return first + second&#125;const total = totalNum(1, 2)// 这种情况下，TypeScipt 无法推断 total 的类型，我们就需要在 totalNum 方法中加入类型注解function totalNum(first: number, second: number)&#123; return first + second&#125;const total = totalNum(1, 2) // 可推断出total 为 number 类型 📌 提示如果 TypeScript 可自行推断出类型，就无需类型注解，只有当 TypeScript 无法推断出类型时，才需加上类型注解。","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"基础","slug":"基础","permalink":"https://yunbochen.github.io/tags/%E5%9F%BA%E7%A1%80/"}],"author":"Rainbow"},{"title":"数组和元祖","slug":"study/typescript/基础/数组和元祖","date":"2021-12-06T00:00:00.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"study/typescript/基础/数组和元祖.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E5%92%8C%E5%85%83%E7%A5%96.html","excerpt":"","text":"数组 TypeScript 的数组和 JavaScript 的数组完全一致，如下代码所示： 1234567891011// 数字数组const numberArr: number[] = [1, 2, 3]// 字符串类型const strArr: string[] = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]// 以此类推...// 数组内的值可以是 number 或 stringconst nameArr: (number | string)[] = [111, &#x27;2&#x27;] 如果数据内的值都是 对象类型 的情况下，对数组的类型修改不太方便，因此我们可以设置 类型别名 ，例如： 12345678type User = &#123; name: string, age?: number&#125;const userArr: User[] = [ &#123; name: &#x27;111&#x27;,age: 2 &#125;, &#123; name: &#x27;2&#x27;&#125;] 元组 数组中元素的数据类型都一般是相同的（ any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用 元组 。 元组 中允许存储不同类型的元素，元组可以作为参数传递给函数。 1const tupleArr: [string, number] = [&#x27;name&#x27;, 1] 其他的使用方法基本与 数组 一致。","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"基础","slug":"基础","permalink":"https://yunbochen.github.io/tags/%E5%9F%BA%E7%A1%80/"}],"author":"Rainbow"},{"title":"TypeScript 前期准备","slug":"study/typescript/基础/前期准备","date":"2021-12-04T00:00:00.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"study/typescript/基础/前期准备.html","link":"","permalink":"https://yunbochen.github.io/study/typescript/%E5%9F%BA%E7%A1%80/%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87.html","excerpt":"","text":"想要使用 TypeScript 需要安装相应的依赖，并编译成普通的 .js 文件 ， .ts 文件 是无法直接使用。 安装依赖 全局安装 cmd 中输入如下命令： 12# 一般国内的直接访问 npm ，非常慢，可使用 --registry 配置命令 定义淘宝源为临时源。npm install -g typescript (--registry = https://registry.npmmirror.com) 项目内安装 cmd 进入项目目录，输入如下命令： 1234567npm init (-y)# 开始时所用的库，使用-Dnpm install -D typescript (--registry = https://registry.npmmirror.com)# 生成 tsconfig.jsontsc --init 📎 关于 tsconfig.json ，请查看文档。 https://www.typescriptlang.org/tsconfigtsconfig.json 配置 tsconfig.json 常用配置 12345678910111213141516171819202122232425262728293031323334&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es2020&quot;, // 指定 TS 编译成 JS 后的js版本 &quot;module&quot;: &quot;commonjs&quot;, // TS 编译成 JS 后采用的模块规范 commonjs amd cmd es等 &quot;lib&quot;: [&quot;DOM&quot;,&quot;ES2020&quot;], /* 指定 TS 编码期间可以使用的库文件版本 比如：ES5就不支持Set集合 */ &quot;outDir&quot;: &quot;./dist&quot;, // 指定 TS 文件编译成 JS 后的输出目录 /* Redirect output structure to the directory. */ &quot;rootDir&quot;: &quot;./src&quot;, // 指定 TS 文件源码目录 &quot;strict&quot;: true, // 启用严格检查模式 &quot;strictNullChecks&quot;:false,// null 和 undefined即是值，也是类型, null 和 undefined 值 只能赋值给 any ,unknown和它们各自的类型 &quot;noImplicitAny&quot;: true, // 一般是指表达式或函数参数上有隐含的 any类型时报错 &quot;experimentalDecorators&quot;: true, /* 启用ES7装饰器实验开启选项 */ &quot;emitDecoratorMetadata&quot;: true, /* 启用装饰器元数据开启选项 */ &quot;declaration&quot;: true, // 指定 TS 文件编译后生成相应的.d.ts文件 &quot;removeComments&quot;: false, // TS 文件编译后删除所有的注释 &quot;baseUrl&quot;: &quot;src&quot;, /* 工作根目录 解析非相对模块的基地址*/ &quot;paths&quot;: &#123; &quot;@/datatype/*&quot;: [&quot;datatype/*&quot;], &quot;@/131/*&quot;: [&quot;131/*&quot;], &quot;@/132/*&quot;: [&quot;132/*&quot;] &#125;, // 有些依赖库底层 为了兼容CommonJs规范、AMD规范这二者的规范中相互兼容， // 使用了 export =，将二者规范统一。 // &quot;esModuleInterop&quot;:true表示允许依赖库中出现export = 这种兼容规范导出的格式， // TS 可以用import from导入 &quot;esModuleInterop&quot;: true, &#125;, &quot;include&quot;: [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题 &quot;./src/**/*.ts&quot;, // 匹配src下所有的ts文件 &quot;src/datatype/typepsenumts&quot; ], &quot;exclude&quot;: [ &quot;./src/**/test&quot;, &quot;./src/**/premit&quot;, ]&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"基础","slug":"基础","permalink":"https://yunbochen.github.io/tags/%E5%9F%BA%E7%A1%80/"}],"author":"Rainbow"},{"title":"Git 提交规范","slug":"note/git/git提交规范","date":"2021-07-05T14:17:52.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"note/git/git提交规范.html","link":"","permalink":"https://yunbochen.github.io/note/git/git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html","excerpt":"","text":"Git 是现在市面上最流行的版本控制工具，书写良好的 commit message 能大大提高代码维护的效率。但是在日常开发中由于缺少对于 commit message 的约束，导致填写内容随意、质量参差不齐，可读性低亦难以维护。在项目中引入 commit message 规范已是迫在眉睫。 用什么规范 现在比较流行的 commit message 规范方案是 约定式提交规范（Conventional Commits），这个方案受到了 Angular提交准则 的启发。在提交信息中描述新特性、bug 修复和破坏性变更，基本的 message 格式大致如下： message 规范12345&lt;类型&gt;[可选的作用域]: &lt;描述&gt;[可选的正文][可选的脚注] 安装相关插件 安装 commitizen &amp; cz-conventional-changelog commitizen : 一个可代替 git commit 的工具，使用该工具系统将提示您在提交时填写所有必需的提交字段。不需要再等到稍后git提交钩子函数来检测提交内容从而拒绝您的提交请求。 commitizen 文档https://github.com/commitizen/cz-cli cz-conventional-changelog : 一个提供 conventional-changelog 标准（约定式提交标准）的适配器。 cz-conventional-changelog 文档https://github.com/commitizen/cz-conventional-changelog 全局安装 全局安装12npm install -g commitizen cz-conventional-changelogecho &#x27;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&#x27; &gt; ~/.czrc 安装完毕后，可直接使用 git cz 来取代 git commit。 全局模式下，需要 ~/.czrc 配置文件, 为 commitizen 指定 Adapter 。 项目内安装 命令行输入： 安装插件1npm install commitizen cz-conventional-changelog -D 在 package.json 添加如下配置： package.json文件123456789101112131415# package.json内添加&#123; ... &quot;scripts&quot;: &#123; ... &quot;commit&quot;: &quot;git-cz&quot;, ... &#125;, &quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;node_modules/cz-conventional-changelog&quot; &#125; &#125;, ...&#125; 安装 commitlint &amp; husky commitlint : 负责用于对 commit message 进行格式校验。 commitlint 文档https://github.com/conventional-changelog/commitlint husky : 提供更易使用的 hook。 husky 文档https://github.com/typicode/husky 安装插件并配置12345678910111213141516171819202122232425# 安装commitlintnpm install @commitlint/config-conventional @commitlint/cli -D# 添加配置文件commitlint.config.jsecho &quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot; &gt; commitlint.config.js# 安装huskynpm install husky -D# package.json内添加&#123; ... &quot;scripts&quot;: &#123; ... &quot;prepare&quot;: &quot;husky install&quot;, ... &#125;, ...&#125;# 激活husky hooknpm run prepare# 添加hooknpx husky add .husky/commit-msg &#x27;npx --no-install commitlint --edit &quot;$1&quot;&#x27; 规范说明 commit message 规则说明 type type 为必填项，用于指定 commit 的类型，约定了 feat、fix 两个主要 type，以及 docs 、style 、build 、refactor 、revert 五个特殊 type，其余 type 一般不使用使用。 主要 type 类型 说明 feat 新增一个功能 fix 修复一个Bug 特殊 type 类型 说明 docs 文档变更 style 代码格式（不影响功能，例如空格、分号等格式修正) build 变更项目构建或外部依赖（例如scopes: webpack、gulp、npm等 refactor 代码重构 revert 代码回退 一般不使用 type 类型 说明 perf 改善性能 test 测试 ci 更改持续集成软件的配置文件和package中的scripts命令，例如scopes: Travis, Circle等 chore 变更构建流程或辅助工具 scope scope 用于描述改动的范围，格式为项目名/模块名。建议 commit 多个模块是，按模块分批次 commit ，这样做易于维护及跟踪。暂时不必填，后期会修改为必填。 body body 填写详细描述，主要描述改动之前的情况及修改动机，对于小的修改不作要求，但是重大需求、更新等必须添加 body 来作说明。 break changes break changes 指明是否产生了破坏性修改，涉及 break changes 的改动必须指明该项，类似版本升级、接口参数减少、接口删除、迁移等。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://yunbochen.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"git","slug":"笔记/git","permalink":"https://yunbochen.github.io/categories/%E7%AC%94%E8%AE%B0/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://yunbochen.github.io/tags/git/"}],"author":"Rainbow"},{"title":"Git 基础操作","slug":"note/git/git基础操作","date":"2021-06-29T16:27:33.000Z","updated":"2022-01-24T03:33:13.994Z","comments":true,"path":"note/git/git基础操作.html","link":"","permalink":"https://yunbochen.github.io/note/git/git%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.html","excerpt":"","text":"虽然 SourceTree 、TortoiseGit 等GUI软件能非常直观便捷的操作 Git 仓库，但掌握 Git 相关基础操作还是必须的。 前期准备（MacOS） 生成SSH密钥并设置 输入如下命令来生成 ssh key： 生成ssh key12ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; # Generating public/private rsa key pair... 这里的 xxxxx@xxxxx.com 只是生成的 ssh key 的名称，并不约束或要求具体命名为某个邮箱。现网的大部分教程均讲解的使用邮箱生成，其一开始的初衷仅仅是为了便于辨识所以使用了邮箱。 按照提示完成三次回车，即可生成 ssh key 。通过查看 ~/.ssh/id_rsa.pub 文件内容，获取到你的 public key 复制id_rsa.pub12cat ~/.ssh/id_rsa.pub# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 将上述的 ssh key 配置到 Github 或者 码云 多个ssh key 配置多个ssh keyhttps://gitee.com/help/articles/4229#article-header Git基础操作 仓库基本管理 初始化一个 Git 仓库 初始化仓库12$ cd 文件夹目录$ git init 将修改的内容提交到本地 Git 暂存区 提交到本地的暂存区123$ git add &#x27;文件&#x27;# 或者$ git add . 或 git add -A (提交当前所有改动) 将暂存区的内容提交到本地 Git 仓库 提交到本地仓库1$ git commit -m &#x27;消息&#x27; 📌 -m 后面为提交的备注信息。 将本地 Git 仓库的信息推送到远程仓库 推送到远程仓库1234$ git push git地址# 若本地已关联了远程仓库$ git push 仓库别名 分支 将远程仓库同步到本地仓库 拉取远程仓库1234$ git pull git地址# 若本地已关联了远程仓库$ git pull 仓库别名 分支 远程仓库管理 修改仓库名 一般来讲，默认情况下，在执行 clone 或者其他操作时，仓库名都是 origin 果说我们想给他改改名字，比如我不喜欢 origin 这个名字，想改为 test 那么就要在仓库目录下执行命令: 修改远程仓库在本地的别名12# 修改远程仓库名字为了test。$ git remote rename origin test 关联仓库 不执行 clone 操作时，想将本地库与远程库管理，可以执行 关联远程仓库1$ git remote add 仓库别名 仓库地址 📌origin 是你的仓库的别名可以随便改，但请务必不要与已有的仓库别名冲突仓库地址一般来讲支持 http/https/ssh/git 协议，其他协议地址请勿添加 查看当前仓库对应的远程仓库地址 查看远程仓库地址1git remote -v 这条命令能显示你当前仓库中已经添加了的仓库名和对应的仓库地址，通常来讲，会有两条一模一样的记录，分别是 fetch 和 push ，其中 fetch 是用来从远程同步，push 是用来推送到远程。 修改仓库对应的远程仓库地址 修改别名的远程仓库地址1git remote set-url origin 仓库地址 仓库分支操作 查看分支 查看分支12$ git branch ( -r |-a ) 📌末尾没有任何尾缀为查看本地所有分支末尾有 -r 为查看远分所有支末尾有 -a 为查看远程和本地所有分支 新建分支，并依然停留在当前分支 新建分支，并依然停留在当前分支1$ git branch 分支名字 新建一个分支，并切换到该分支 新建一个分支，并切换到该分支1$ git checkout -b 分支名字 新建一个分支，指向指定commit 新建一个分支，指向指定commit1$ git branch 分支名字 commit记录 本地新建一个分支，并推送到远程 本地新建一个分支，并推送到远程12$ git checkout -b 分支名字 $ git push 仓库名 分支名字:分支名字 #远程没有该分支会自动创建 切换到指定分支，并更新工作区 切换到指定分支，并更新工作区1$ git checkout 分支名字 合并指定分支到当前分支区 合并指定分支到当前分支区1$ git merge 分支名字 删除分支 删除分支1$ git branch -d 分支名字 删除远程分支 删除远程分支123$ git push origin --delete 分支名字# 或者$ git branch -dr [仓库名/分支名字] 提交规范 主要 type 类型 说明 feat 新增一个功能 fix 修复一个Bug 特殊 type 类型 说明 docs 文档变更 style 代码格式（不影响功能，例如空格、分号等格式修正) build 变更项目构建或外部依赖（例如scopes: webpack、gulp、npm等 refactor 代码重构 revert 代码回退 一般不使用 type 类型 说明 perf 改善性能 test 测试 ci 更改持续集成软件的配置文件和package中的scripts命令，例如scopes: Travis, Circle等 chore 变更构建流程或辅助工具 其他 更多 Git 操作https://gitee.com/all-about-git 常见问题 合并分支报无相关历史 合并分支报无相关历史1git merge 分支名 --allow-unrelated-historie github 于 2020年10月1日 起，默认分支为main，而本地创建默认分支仍未master，怎么推送 推送到远程仓库某个分支1git push origin matser:main","categories":[{"name":"笔记","slug":"笔记","permalink":"https://yunbochen.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"git","slug":"笔记/git","permalink":"https://yunbochen.github.io/categories/%E7%AC%94%E8%AE%B0/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://yunbochen.github.io/tags/git/"}],"author":"Rainbow"}],"categories":[{"name":"笔记","slug":"笔记","permalink":"https://yunbochen.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"nodejs","slug":"笔记/nodejs","permalink":"https://yunbochen.github.io/categories/%E7%AC%94%E8%AE%B0/nodejs/"},{"name":"学习","slug":"学习","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"typescript","slug":"学习/typescript","permalink":"https://yunbochen.github.io/categories/%E5%AD%A6%E4%B9%A0/typescript/"},{"name":"git","slug":"笔记/git","permalink":"https://yunbochen.github.io/categories/%E7%AC%94%E8%AE%B0/git/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://yunbochen.github.io/tags/nodejs/"},{"name":"file","slug":"file","permalink":"https://yunbochen.github.io/tags/file/"},{"name":"node","slug":"node","permalink":"https://yunbochen.github.io/tags/node/"},{"name":"脚手架","slug":"脚手架","permalink":"https://yunbochen.github.io/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"name":"typescript","slug":"typescript","permalink":"https://yunbochen.github.io/tags/typescript/"},{"name":"高级","slug":"高级","permalink":"https://yunbochen.github.io/tags/%E9%AB%98%E7%BA%A7/"},{"name":"进阶","slug":"进阶","permalink":"https://yunbochen.github.io/tags/%E8%BF%9B%E9%98%B6/"},{"name":"基础","slug":"基础","permalink":"https://yunbochen.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"git","slug":"git","permalink":"https://yunbochen.github.io/tags/git/"}]}